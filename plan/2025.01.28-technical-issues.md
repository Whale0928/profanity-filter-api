# 기술 부채 및 개선 사항

분석 일자: 2025-01-28

## Critical (긴급)

### 1. NormalProfanityFilter 동시성 제어 부족

**파일**: `profanity-domain/src/main/java/app/application/filter/NormalProfanityFilter.java:28`

**문제**:
```java
private static volatile Trie trie;
private Set<String> collect = new HashSet<>();  // Thread-unsafe
```
- `collect` Set이 동기화되지 않음
- SyncScheduler와 API 요청이 동시 접근 시 ConcurrentModificationException 가능
- 데이터 정합성 문제 발생 가능

**해결 방안**:
```java
private volatile Set<String> collect = ConcurrentHashMap.newKeySet();
```

**예상 작업 시간**: 1시간
**비즈니스 영향**: 높음 (데이터 정합성)

---

### 2. CORS 보안 취약점

**파일**: `profanity-api/src/main/java/app/security/SecurityConfig.java:72-73`

**문제**:
```java
configuration.setAllowCredentials(false);
configuration.setAllowedOrigins(List.of("*")); // 모든 Origin 허용
```
- 모든 도메인에서 API 호출 가능
- CSRF 공격 취약
- Credentials와 wildcard Origin 동시 사용 불가

**해결 방안**:
```java
configuration.setAllowedOrigins(List.of(
    "https://prod.example.com",
    "https://api.example.com"
));
// 또는 환경 변수로 관리
configuration.setAllowedOrigins(Arrays.asList(
    environment.getProperty("cors.allowed.origins", "").split(",")
));
```

**예상 작업 시간**: 30분
**비즈니스 영향**: 높음 (보안)

---

## High (중요)

### 3. 캐시 무효화 전략 없음

**파일**: `profanity-api/src/main/java/app/presentation/ProfanityController.java:37`

**문제**:
```java
@Cacheable(value = "request_filter", key = "#request.text + '_' + #request.mode")
```
- 비속어 DB 업데이트 시 캐시가 갱신되지 않음
- 오래된 필터링 결과 반환 가능
- 캐시 키가 단순 문자열 결합 (긴 텍스트 시 메모리 낭비)

**해결 방안**:
```java
// SyncScheduler.java
@Autowired
private CacheManager cacheManager;

public void synchronizeProfanityData() {
    long counted = profanityRepository.countAll();
    if (counted != count) {
        syncFilter.synchronizeProfanityTrie();
        cacheManager.getCache("request_filter").clear(); // 캐시 클리어
        count = counted;
    }
}

// 캐시 키 개선
@Cacheable(value = "request_filter",
    key = "T(java.util.Objects).hash(#request.text) + '_' + #request.mode")
```

**예상 작업 시간**: 2시간
**비즈니스 영향**: 중간 (정확도)

---

### 4. 테스트 커버리지 부족

**현재 상태**:
- 전체 테스트: 15개
- 코드 라인 수: ~3,900 LOC
- 예상 커버리지: 20% 미만

**누락된 테스트**:
- `NormalProfanityFilter.allMatched()` - 핵심 필터링 알고리즘
- `DefaultProfanityHandler` - 비즈니스 로직
- `SyncScheduler` - 동기화 로직
- `ClientsCommandService` - 클라이언트 관리

**해결 방안**:
```bash
# 우선순위 테스트 작성
1. NormalProfanityFilterTest - 다양한 입력 케이스
2. DefaultProfanityHandlerTest - 모드별 처리
3. SyncSchedulerTest - 동기화 시나리오
4. ClientsCommandServiceTest - API Key 생성/검증
```

**목표**: 80% 이상 커버리지
**예상 작업 시간**: 2주
**비즈니스 영향**: 중간 (안정성)

---

### 5. SyncScheduler ShedLock 미적용

**파일**: `profanity-domain/src/main/java/app/application/manage/SyncScheduler.java:31`

**문제**:
```java
@Scheduled(fixedDelay = 60000)
public void synchronizeProfanityData() {
    // ShedLock 미적용
}
```
- `DailyReportScheduler`는 `@SchedulerLock` 사용 중
- `SyncScheduler`는 분산 환경에서 중복 실행 가능
- 불필요한 DB 조회 및 Trie 재빌드

**해결 방안**:
```java
@Scheduled(fixedDelay = 60000)
@SchedulerLock(name = "sync_profanity_trie", lockAtMostFor = "PT2M")
public void synchronizeProfanityData() {
    // 기존 로직
}
```

**예상 작업 시간**: 30분
**비즈니스 영향**: 중간 (성능)

---

## Medium (개선)

### 6. Rate Limiting 부재

**현재 상태**:
- API 호출 제한 없음
- DDoS 공격에 취약
- 특정 클라이언트의 과도한 요청 차단 불가

**해결 방안**:
```java
// build.gradle에 의존성 추가
implementation 'com.github.vladimir-bukhtoyarov:bucket4j-core:8.1.0'
implementation 'com.github.vladimir-bukhtoyarov:bucket4j-redis:8.1.0'

// RateLimitingAspect 생성
@Aspect
public class RateLimitingAspect {
    private final Map<String, Bucket> buckets = new ConcurrentHashMap<>();

    @Around("@annotation(app.security.annotation.RateLimited)")
    public Object rateLimit(ProceedingJoinPoint joinPoint) {
        String apiKey = SecurityContextUtil.getApiKey();
        Bucket bucket = buckets.computeIfAbsent(apiKey, k ->
            Bucket.builder()
                .addLimit(Bandwidth.classic(100, Duration.ofMinutes(1)))
                .build()
        );

        if (bucket.tryConsume(1)) {
            return joinPoint.proceed();
        } else {
            throw new RateLimitExceededException();
        }
    }
}
```

**예상 작업 시간**: 1일
**비즈니스 영향**: 중간 (안정성)

---

### 7. 트랜잭션 전파 속성 모호

**파일**:
- `profanity-domain/src/main/java/app/application/filter/DefaultProfanityHandler.java:42`
- `profanity-domain/src/main/java/app/application/event/FilterEventHandler.java:16-17`

**문제**:
```java
@Transactional  // 기본 REQUIRED 사용
public FilterApiResponse requestFacadeFilter(...) {
    publisher.publishEvent(FilterEvent.create(request, response));
}

// FilterEventHandler.java
// @Transactional(propagation = REQUIRES_NEW)  // 주석 처리됨
// @TransactionalEventListener
@EventListener
public void handle(FilterEvent event) {
    trackingRecorder.recordTracking(event);
}
```
- 이벤트 핸들러의 트랜잭션 전파 전략이 불명확
- 필터링 실패 시 이벤트 저장 여부 불분명

**해결 방안**:
```java
// 필터링과 이벤트 저장을 분리할 경우
@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void handle(FilterEvent event) {
    trackingRecorder.recordTracking(event);
}

// 또는 동일 트랜잭션 내에서 처리할 경우
@EventListener
public void handle(FilterEvent event) {
    trackingRecorder.recordTracking(event);
}
```

**예상 작업 시간**: 2시간
**비즈니스 영향**: 낮음 (설계 명확화)

---

### 8. API Key 로그 노출

**파일**: `profanity-api/src/main/java/app/presentation/ProfanityController.java:47`

**문제**:
```java
log.info("api key : {}", apiKey);  // API Key 평문 로깅
```
- API Key가 로그 파일에 평문으로 저장
- 로그 유출 시 보안 위험

**해결 방안**:
```java
// 유틸리티 메서드
public static String maskApiKey(String apiKey) {
    if (apiKey == null || apiKey.length() < 8) {
        return "****";
    }
    return apiKey.substring(0, 4) + "****" + apiKey.substring(apiKey.length() - 4);
}

// 사용
log.info("api key : {}", maskApiKey(apiKey));
```

**예상 작업 시간**: 1시간
**비즈니스 영향**: 낮음 (보안 개선)

---

## 추가 발견 사항

### 필터링 알고리즘 성능 병목

**파일**: `profanity-domain/src/main/java/app/application/filter/NormalProfanityFilter.java:75-95`

**문제**:
```java
String cleanedText = text.replaceAll("[^ㄱ-ㅎㅏ-ㅣ가-힣a-zA-Z\\s]", "");
for (Emit emit : trie.parseText(cleanedText)) {
    int startPos = text.indexOf(emit.getKeyword().charAt(0), currentPos);
    for (char c : emit.getKeyword().toCharArray()) {
        endPos = text.indexOf(c, endPos) + 1;
    }
}
```
- 정규식 + 다중 indexOf 호출
- 긴 텍스트(1MB+)에서 O(n²) 성능 저하 가능

**해결 방안**:
- 단일 패스 알고리즘으로 리팩토링
- JMH 벤치마크 테스트 작성
- 성능 프로파일링 후 최적화

**예상 작업 시간**: 1주
**비즈니스 영향**: 낮음 (대부분 텍스트는 짧음)

---

### NPE 예외 처리 잘못됨

**파일**: `profanity-api/src/main/java/app/exception/GlobalExceptionHandler.java:101-106`

**문제**:
```java
@ExceptionHandler(NullPointerException.class)
public ResponseEntity<ApiResponse<Void>> handleNullPointerException(...) {
    StatusCode resolve = StatusCode.resolve(ex.getMessage());
    return ApiResponse.error(Status.of(resolve));
}
```
- NPE를 비즈니스 예외로 처리 (잘못된 설계)
- NPE는 프로그래밍 오류이므로 500 에러로 처리해야 함

**해결 방안**:
```java
@ExceptionHandler(NullPointerException.class)
public ResponseEntity<ApiResponse<Void>> handleNullPointerException(...) {
    log.error("Unexpected NullPointerException", ex);
    return ApiResponse.error(Status.of(StatusCode.INTERNAL_SERVER_ERROR));
}

// 비즈니스 로직에서는 Optional 사용
Optional<Clients> client = clientRepository.findByApiKey(apiKey);
if (client.isEmpty()) {
    throw new BusinessException(StatusCode.NOT_FOUND_CLIENT);
}
```

**예상 작업 시간**: 2시간
**비즈니스 영향**: 낮음 (디버깅 개선)

---

## 우선순위 요약

| 순위 | 이슈 | 예상 시간 | 영향도 |
|------|------|----------|--------|
| 1 | NormalProfanityFilter 동시성 | 1시간 | 높음 |
| 2 | CORS 보안 취약점 | 30분 | 높음 |
| 3 | SyncScheduler ShedLock | 30분 | 중간 |
| 4 | 캐시 무효화 전략 | 2시간 | 중간 |
| 5 | API Key 로그 노출 | 1시간 | 낮음 |
| 6 | 트랜잭션 전파 속성 | 2시간 | 낮음 |
| 7 | Rate Limiting | 1일 | 중간 |
| 8 | 테스트 커버리지 | 2주 | 중간 |

**권장 작업 순서**: 1 → 2 → 3 → 4 → 5 → 6 → 7 → 8