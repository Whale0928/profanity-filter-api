name: Test and Health Check

on:
  pull_request:
    branches:
      - '**'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: JDK 21 설정
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Configure 1Password Service Account
        uses: 1password/load-secrets-action/configure@v2
        with:
          service-account-token: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

      - name: Server host secret setup
        id: op-load-server-secret
        uses: 1password/load-secrets-action@v2
        with:
          export-env: true
          unset-previous: false
        env:
          ENV_FILE: op://instance/.env/.env

      - name: 환경 변수 파일 생성
        run: |
          echo "${{ env.ENV_FILE }}" > .env

      - name: 테스트 실행
        run: ./gradlew test

      - name: 테스트 결과 업로드
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            **/build/reports/tests/
            **/build/test-results/

  # 보안 취약점 스캔 작업 - 테스트와 병렬로 실행
  security-scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: JDK 21 설정
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      # OWASP Dependency Check를 사용한 보안 취약점 스캔
      # - 프로젝트의 의존성에서 알려진 보안 취약점을 탐지
      # - NIST NVD (National Vulnerability Database) 기반
      # - CVSS 점수 7.0 이상의 취약점 발견 시 빌드 실패
      - name: OWASP Dependency Check 보안 스캔
        uses: dependency-check/Dependency-Check_Action@main
        id: dep-check
        with:
          # 프로젝트 이름 설정
          project: 'profanity-filter-api'
          # 스캔할 경로 (현재 디렉토리 전체)
          path: '.'
          # 리포트 형식 (HTML: 사람이 읽기 쉬운 형태, JSON: 기계 처리용)
          format: 'HTML,JSON'
          # 출력 디렉토리
          out: 'reports'
          # 추가 옵션:
          # --failOnCVSS 7: CVSS 점수 7.0 이상의 취약점 발견 시 실패
          # --enableRetired: 사용 중단된 의존성도 스캔에 포함
          # --enableExperimental: 실험적 분석기 활성화
          args: >
            --failOnCVSS 7
            --enableRetired
            --enableExperimental
        # 실패해도 다음 단계 계속 진행 (리포트 확인을 위해)
        continue-on-error: true

      # 생성된 파일들의 실제 위치 확인
      - name: 리포트 파일 위치 확인
        if: always()
        run: |
          echo "=== 현재 작업 디렉토리 구조 확인 ==="
          pwd
          ls -la
          
          echo "\n=== reports 디렉토리 확인 ==="
          if [ -d "reports" ]; then
            echo "✅ reports 디렉토리 존재"
            ls -la reports/
          else
            echo "❌ reports 디렉토리 없음"
          fi
          
          echo "\n=== dependency-check 관련 파일 검색 ==="
          find . -name "*dependency-check*" -type f 2>/dev/null | head -10 || echo "dependency-check 관련 파일 없음"
          
          echo "\n=== .html 파일 검색 ==="
          find . -name "*.html" -type f 2>/dev/null | head -10 || echo "HTML 파일 없음"
          
          echo "\n=== .json 파일 검색 ==="
          find . -name "*.json" -type f 2>/dev/null | head -10 || echo "JSON 파일 없음"

      # 스캔 결과를 GitHub Actions 아티팩트로 업로드
      # 실패하더라도 결과를 확인할 수 있도록 always() 조건 사용
      - name: 보안 스캔 결과 업로드
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-scan-report
          # 여러 가능한 경로에서 리포트 파일 찾기
          path: |
            reports/
            **/dependency-check-report.*
            dependency-check-report.*
          # 아티팩트 보존 기간 (일 단위)
          retention-days: 30
          # 파일이 없어도 오류를 발생시키지 않음
          if-no-files-found: warn

      # 스캔 결과 요약을 GitHub PR 코멘트나 로그에 출력
      - name: 보안 스캔 결과 요약
        if: always()
        run: |
          echo "=== OWASP Dependency Check 보안 스캔 완료 ==="
          echo "스캔 대상: ${{ github.workspace }}"
          
          # 리포트 파일 위치 자동 감지
          HTML_REPORT=""
          JSON_REPORT=""
          
          # 여러 가능한 경로에서 HTML 리포트 찾기
          if [ -f "reports/dependency-check-report.html" ]; then
            HTML_REPORT="reports/dependency-check-report.html"
          elif [ -f "dependency-check-report.html" ]; then
            HTML_REPORT="dependency-check-report.html"
          else
            HTML_REPORT=$(find . -name "dependency-check-report.html" -type f 2>/dev/null | head -1)
          fi
          
          # 여러 가능한 경로에서 JSON 리포트 찾기
          if [ -f "reports/dependency-check-report.json" ]; then
            JSON_REPORT="reports/dependency-check-report.json"
          elif [ -f "dependency-check-report.json" ]; then
            JSON_REPORT="dependency-check-report.json"
          else
            JSON_REPORT=$(find . -name "dependency-check-report.json" -type f 2>/dev/null | head -1)
          fi
          
          # 결과 출력
          if [ -n "$HTML_REPORT" ] && [ -f "$HTML_REPORT" ]; then
            echo "✅ HTML 리포트가 생성되었습니다: $HTML_REPORT"
            echo "📊 상세 결과는 아티팩트에서 다운로드하여 확인하세요."
          else
            echo "⚠️ HTML 리포트를 찾을 수 없습니다."
          fi
          
          if [ -n "$JSON_REPORT" ] && [ -f "$JSON_REPORT" ]; then
            echo "📋 JSON 리포트가 생성되었습니다: $JSON_REPORT"
          else
            echo "⚠️ JSON 리포트를 찾을 수 없습니다."
          fi
          
          # 전체 스캔 결과 요약
          if [ -n "$HTML_REPORT" ] || [ -n "$JSON_REPORT" ]; then
            echo "🔒 보안 스캔이 완료되었습니다."
          else
            echo "❌ 보안 스캔 리포트 생성에 문제가 발생했습니다."
          fi

  # 헬스체크 작업 - 테스트와 보안 스캔이 모두 성공한 후 실행
  health-check:
    needs: [ test, security-scan ]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: JDK 21 설정
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Configure 1Password Service Account
        uses: 1password/load-secrets-action/configure@v2
        with:
          service-account-token: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}

      - name: Server host secret setup
        id: op-load-server-secret
        uses: 1password/load-secrets-action@v2
        with:
          export-env: true
          unset-previous: false
        env:
          ENV_FILE: op://instance/.env/.env

      - name: 환경 변수 파일 생성
        run: |
          echo "${{ env.ENV_FILE }}" > .env

      - name: Docker 이미지 빌드 및 컨테이너 실행
        run: |
          # 배포 스크립트와 동일한 로직으로 컨테이너 배포
          chmod +x script/container_deploy.sh
          cd script
          
          # 배포 스크립트 실행 및 결과 수집
          DEPLOY_OUTPUT=$(./container_deploy.sh)
          echo "$DEPLOY_OUTPUT"
          
          # 배포 결과에서 포트 추출 (deploy.yml과 동일한 로직)
          DEPLOYED_INFO=$(echo "$DEPLOY_OUTPUT" | grep "DEPLOY_RESULT:" | tail -n1)
          DEPLOYED_PORT=$(echo "$DEPLOYED_INFO" | cut -d':' -f4)
          
          echo "배포된 포트: $DEPLOYED_PORT"
          echo "DEPLOYED_PORT=$DEPLOYED_PORT" >> $GITHUB_ENV

      - name: 헬스체크 수행
        run: |
          # 헬스체크 설정 (deploy.yml과 동일한 로직)
          MAX_RETRIES=30
          RETRY_COUNT=0
          HEALTH_CHECK_URL="http://localhost:${{ env.DEPLOYED_PORT }}/api/v1/health"
          
          echo "배포된 포트: ${{ env.DEPLOYED_PORT }}에서 헬스체크를 수행합니다."
          echo "헬스체크 URL: $HEALTH_CHECK_URL"
          
          # 애플리케이션이 시작될 때까지 대기
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" $HEALTH_CHECK_URL || echo "000")
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "✅ 애플리케이션이 정상적으로 실행 중입니다. (HTTP 상태: $HTTP_STATUS)"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "⏳ 애플리케이션이 아직 준비되지 않았습니다. 재시도 $RETRY_COUNT/$MAX_RETRIES (HTTP 상태: $HTTP_STATUS)"
              sleep 10 
            fi
          done
          
          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "❌ 헬스 체크 실패: 애플리케이션이 제한 시간 내에 시작되지 않았습니다."
            exit 1
          fi
          echo "🎉 배포 및 헬스 체크가 성공적으로 완료되었습니다."

      - name: 컨테이너 정리
        if: always()
        run: |
          # 테스트용으로 실행된 컨테이너들 정리
          echo "테스트용 컨테이너 정리 중..."
          
          # 실행 중인 profanity 컨테이너들 확인 및 정리
          BLUE_CONTAINER=$(docker ps -q --filter "name=profanity-blue")
          GREEN_CONTAINER=$(docker ps -q --filter "name=profanity-green")
          
          if [ -n "$BLUE_CONTAINER" ]; then
            echo "Blue 컨테이너 정리 중..."
            docker stop $BLUE_CONTAINER || true
            docker rm $BLUE_CONTAINER || true
          fi
          
          if [ -n "$GREEN_CONTAINER" ]; then
            echo "Green 컨테이너 정리 중..."
            docker stop $GREEN_CONTAINER || true
            docker rm $GREEN_CONTAINER || true
          fi
          
          # 사용하지 않는 이미지 정리
          docker image prune -f || true
          
          echo "컨테이너 정리가 완료되었습니다."
