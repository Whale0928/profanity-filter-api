plugins {
    id 'java'
    id 'org.springframework.boot' version '3.4.0'
    id 'io.spring.dependency-management' version '1.1.6'
    id 'jacoco'
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

allprojects {
    version = '0.0.1-SNAPSHOT'
    group = 'app.profanity-filter'

    repositories {
        mavenCentral()
    }

    java {
        sourceCompatibility = '21'
        targetCompatibility = '21'
    }
}

subprojects {
    apply plugin: 'java-library'
    apply plugin: 'org.springframework.boot'
    apply plugin: 'io.spring.dependency-management'
    apply plugin: 'jacoco'

    dependencies {
        // default spring boot dependencies
        implementation 'org.springframework.boot:spring-boot-starter'
        testImplementation 'org.springframework.boot:spring-boot-starter-test'
        annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'
        implementation 'org.springframework.boot:spring-boot-configuration-processor'

        // default  utilities
        implementation 'org.apache.commons:commons-lang3:3.12.0'
        implementation 'com.google.guava:guava:31.1-jre'

        // default lombok
        implementation 'org.projectlombok:lombok'
        annotationProcessor 'org.projectlombok:lombok'


        // Cache
        implementation 'org.springframework.boot:spring-boot-starter-cache'
        implementation "com.github.ben-manes.caffeine:caffeine:3.1.8"
    }

    bootJar.enabled = false
    jar.enabled = true
    tasks.named('test') { useJUnitPlatform() }

    // JaCoCo configuration
    jacoco {
        toolVersion = "0.8.11"
    }

    test {
        outputs.upToDateWhen { false }
        useJUnitPlatform()
        testLogging {
            events "passed", "skipped", "failed"
            showStandardStreams = true
            exceptionFormat = 'full'
            showExceptions = true
            showCauses = true
            showStackTraces = true
        }
        finalizedBy jacocoTestReport
    }

    jacocoTestReport {
        dependsOn test
        reports {
            xml.required = true
            html.required = true
            csv.required = false
        }

        afterEvaluate {
            classDirectories.setFrom(files(classDirectories.files.collect {
                fileTree(dir: it, exclude: [
                    '**/config/**',
                    '**/entity/**',
                    '**/dto/**',
                    '**/*Application.class'
                ])
            }))
        }
    }

    // Define coverage targets for each module
    ext {
        coverageTargets = [
            'profanity-api': [
                line: 0.70,
                branch: 0.65,
                instruction: 0.70
            ],
            'profanity-domain': [
                line: 0.80,
                branch: 0.75,
                instruction: 0.80
            ],
            'profanity-shared': [
                line: 0.60,
                branch: 0.55,
                instruction: 0.60
            ],
            'rdb': [
                line: 0.70,
                branch: 0.65,
                instruction: 0.70
            ],
            'redis': [
                line: 0.70,
                branch: 0.65,
                instruction: 0.70
            ]
        ]
    }

    // Task to check coverage targets (without enforcing)
    tasks.register('checkCoverageTargets') {
        dependsOn jacocoTestReport
        doLast {
            def reportFile = file("${buildDir}/reports/jacoco/test/jacocoTestReport.xml")
            if (reportFile.exists()) {
                try {
                    def parser = new XmlParser()
                    parser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
                    parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
                    def report = parser.parse(reportFile)

                    def moduleName = project.name
                    def targets = project.coverageTargets[moduleName]

                    if (targets != null) {
                        def counters = report.counter
                        def lineCoverage = getCoverage(counters, 'LINE')
                        def branchCoverage = getCoverage(counters, 'BRANCH')
                        def instructionCoverage = getCoverage(counters, 'INSTRUCTION')

                        println "\n=========================================="
                        println "üìä Coverage Report for ${moduleName}"
                        println "=========================================="
                        println "Line Coverage:        ${String.format('%.2f%%', lineCoverage * 100)} (Target: ${String.format('%.0f%%', targets.line * 100)}) ${lineCoverage >= targets.line ? '‚úÖ' : '‚ùå'}"
                        println "Branch Coverage:      ${String.format('%.2f%%', branchCoverage * 100)} (Target: ${String.format('%.0f%%', targets.branch * 100)}) ${branchCoverage >= targets.branch ? '‚úÖ' : '‚ùå'}"
                        println "Instruction Coverage: ${String.format('%.2f%%', instructionCoverage * 100)} (Target: ${String.format('%.0f%%', targets.instruction * 100)}) ${instructionCoverage >= targets.instruction ? '‚úÖ' : '‚ùå'}"
                        println "==========================================\n"
                    }
                } catch (Exception e) {
                    println "‚ö†Ô∏è  Warning: Could not parse coverage report for ${project.name}: ${e.message}"
                }
            } else {
                println "‚ö†Ô∏è  Warning: Coverage report not found for ${project.name}"
            }
        }
    }
}

// Helper function to calculate coverage
def getCoverage(counters, type) {
    def counter = counters.find { it.'@type' == type }
    if (counter != null) {
        def missed = counter.'@missed'.toInteger()
        def covered = counter.'@covered'.toInteger()
        def total = missed + covered
        return total > 0 ? covered / total : 0.0
    }
    return 0.0
}

// Root ÌîÑÎ°úÏ†ùÌä∏Ïùò test taskÎ•º ÏàòÏ†ï
test.dependsOn subprojects.test

// Unified coverage report for all modules
tasks.register('jacocoRootReport', JacocoReport) {
    description = 'Generates an aggregate report from all subprojects'
    group = 'Reporting'

    reports {
        xml.required = true
        html.required = true
        csv.required = true
    }

    doLast {
        println "\n=========================================="
        println "üìä Unified Coverage Report Generated"
        println "=========================================="
        println "HTML Report: ${reports.html.outputLocation.get()}/index.html"
        println "XML Report:  ${reports.xml.outputLocation.get()}"
        println "==========================================\n"
    }
}

project.afterEvaluate {
    tasks.named('jacocoRootReport').configure {
        // Explicit dependencies on all test and jacocoTestReport tasks
        dependsOn subprojects.test
        dependsOn subprojects.jacocoTestReport

        additionalSourceDirs.setFrom files(subprojects.sourceSets.main.allSource.srcDirs)
        sourceDirectories.setFrom files(subprojects.sourceSets.main.allSource.srcDirs)

        def allClassDirs = files(subprojects.sourceSets.main.output).files.collect {
            fileTree(dir: it, exclude: [
                '**/config/**',
                '**/entity/**',
                '**/dto/**',
                '**/*Application.class'
            ])
        }
        classDirectories.setFrom files(allClassDirs)

        executionData.setFrom project.fileTree(dir: '.', include: '**/build/jacoco/test.exec')
    }
}

// Task to check overall coverage target
tasks.register('checkOverallCoverageTarget') {
    dependsOn jacocoRootReport
    doLast {
        def reportFile = file("${buildDir}/reports/jacoco/jacocoRootReport/jacocoRootReport.xml")
        if (reportFile.exists()) {
            try {
                def parser = new XmlParser()
                parser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
                parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
                def report = parser.parse(reportFile)

                def counters = report.counter
                def lineCoverage = getCoverage(counters, 'LINE')
                def branchCoverage = getCoverage(counters, 'BRANCH')
                def instructionCoverage = getCoverage(counters, 'INSTRUCTION')

                // Overall project targets
                def overallTargets = [
                    line: 0.75,
                    branch: 0.70,
                    instruction: 0.75
                ]

                println "\n=========================================="
                println "üéØ Overall Project Coverage Report"
                println "=========================================="
                println "Line Coverage:        ${String.format('%.2f%%', lineCoverage * 100)} (Target: ${String.format('%.0f%%', overallTargets.line * 100)}) ${lineCoverage >= overallTargets.line ? '‚úÖ' : '‚ùå'}"
                println "Branch Coverage:      ${String.format('%.2f%%', branchCoverage * 100)} (Target: ${String.format('%.0f%%', overallTargets.branch * 100)}) ${branchCoverage >= overallTargets.branch ? '‚úÖ' : '‚ùå'}"
                println "Instruction Coverage: ${String.format('%.2f%%', instructionCoverage * 100)} (Target: ${String.format('%.0f%%', overallTargets.instruction * 100)}) ${instructionCoverage >= overallTargets.instruction ? '‚úÖ' : '‚ùå'}"
                println "==========================================\n"
            } catch (Exception e) {
                println "‚ö†Ô∏è  Warning: Could not parse overall coverage report: ${e.message}"
            }
        } else {
            println "‚ö†Ô∏è  Warning: Overall coverage report not found"
        }
    }
}

bootJar.enabled = false
jar.enabled = true
